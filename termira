#!/usr/bin/env python3

from jira import JIRA
import json
import curses
from datetime import datetime, timedelta
from traceback import print_exc
import configparser
from curses.textpad import Textbox
import locale
from jira.exceptions import JIRAError
from subprocess import Popen, check_output, DEVNULL
from signal import signal, SIGCHLD, SIG_IGN
from os import path, chdir

COLORS = {
    'default': 0,
    'bar': 1,
}

chdir(path.dirname(path.abspath(__file__)))

locale.setlocale(locale.LC_ALL, '')

config = configparser.ConfigParser()
query = ''

termira_version = check_output(['git', 'describe', '--always']).decode('utf-8').strip()



def line(msg, width):
    return msg[:width] + ' ' * (width - len(msg))



def addstr(win, *args, **kwargs):
    try:
        win.addstr(*args, **kwargs)
    except curses.error:
        pass



def title(win, msg):
    height, width = win.getmaxyx()
    addstr(win, 0, 0, line(msg, width), curses.color_pair(COLORS['bar']))



def status(win, msg):
    height, width = win.getmaxyx()
    addstr(win, height - 1, 0, line(msg, width), curses.color_pair(COLORS['bar']))



def default_status(screen, query, refresh_delta, refresh_every):
    height, width = screen.getmaxyx()

    fraction = refresh_delta.total_seconds() / refresh_every.total_seconds()
    fraction = max(0, min(1, fraction))
    fill_len = 10
    fill = int(fill_len * fraction)
    fill_pad = fill_len - fill
    msg = '█' * fill + '░' * fill_pad + '  '+query

    return msg



def textbox_input_validator(key):
    if key in ['KEY_BACKSPACE', '\b', 127]:
        return curses.KEY_BACKSPACE

    return key

def query_string(win, prompt):
    height, width = win.getmaxyx()
    addstr(win, height - 1, 0, prompt, curses.color_pair(COLORS['bar']))
    curses.curs_set(True)
    win.refresh()

    editwin = curses.newwin(1, width - len(prompt), height - 1, len(prompt))
    box = Textbox(editwin)
    box.edit(textbox_input_validator)
    out = box.gather()

    curses.curs_set(False)
    del editwin
    win.touchwin()
    win.refresh()

    return out.strip()



def show_help_screen(win):
    msg = '''
    q        Quit program
    ?        Help

    r        Refresh
    R        Reload Queries from config (resets query selection to first in list)

    t        Transition Issue

    l        Open Issue Permalink

    j, k     Scroll one line down / up
    g, G     Scroll to top / bottom
    ^F, ^G   Scroll half a page down / up
    '''

    height, width = win.getmaxyx()
    at_y = margin = 2
    for m in msg.strip().splitlines():
        if at_y >= height - margin:
            break

        m = m.strip()
        addstr(win, at_y, margin, m, curses.color_pair(COLORS['default']))
        at_y += 1

    at_y += margin*2
    query_key_length = 5

    for query in config['queries'].keys():
        if len(query) > query_key_length:
            query_key_length = len(query)

    format_string = '{:>' + str(query_key_length) + 's}  {:s}'

    addstr(win, at_y, margin, format_string.format('Alias', 'JQL'))
    at_y += 1

    for alias, query in config['queries'].items():
        if at_y >= height - margin:
            break

        addstr(win, at_y, margin, format_string.format(alias, query))
        at_y +=1



def show_transition(screen, offset, current, issues):
    height, width = screen.getmaxyx()
    y = margin = 2

    try:
        issue = issues[current].key
        summary = issues[current].fields.summary

        transitions = jira.transitions(issue)
    except:
        addstr(screen, margin, margin, 'Error while getting transitions')

        return False

    addstr(screen, y, margin, issue+': '+summary)

    y += 2

    for t in transitions:
        addstr(screen, y, margin, '{:5s}  {:s}'.format(t['id'], t['name']))

        y += 1

    transition = query_string(screen, 'Transition ID: ')

    for t in transitions:
        if transition == t['id']:
            jira.transition_issue(issue, t['id'])
            status(screen, 'Transitioning to '+t['name'])

            return True

    return False


def fmt_line(line_tuple, lens, total_max_width):
    # Takes a tuple (the individual columns) and a dict of lengths.
    # Creates a string where each column is padded to the given length.
    # The total length, however, will not exceed "total_max_width".

    formatted_tuples = []
    for i, element in enumerate(line_tuple):
        # Truncate individual columns if they exceed the configured
        # length.
        if len(element) > lens[i]:
            element = element[:lens[i] - 1] + '…'
        formatted_tuples.append(('{:' + str(lens[i]) + 's}').format(element))
    out = '  '.join(formatted_tuples)
    # Truncate final output if needed.
    if len(out) > total_max_width:
        out = out[:total_max_width - 1] + '…'
    return out


def show_issues(screen, offset, current, issues):
    height, width = screen.getmaxyx()

    margin_top = margin_bottom = 1
    description_lines = []

    try:
        # issue description fields may be longer than screen width, so
        # we get the first 10 lines of text, then split it into words,
        # then assemble the lines back so they fit into the screen.

        i = 0
        for l in issues[current].fields.description.split("\n")[:10]:
            tmp_line = []

            for word in l.split():
                if (len(' '.join(tmp_line)) + len(word) + 1) > width:
                    description_lines.append(' '.join(tmp_line))
                    tmp_line = []

                tmp_line.append(word)

            description_lines.append(' '.join(tmp_line))

    except:
        pass # silently ignore all errors in try block

    additional_lines_needed = len(description_lines) + 1

    usable_height_for_items = height - margin_top - margin_bottom - additional_lines_needed
    if usable_height_for_items <= 0:
        return 0

    # scroll the upper half of the window if currently selected issue
    # is not visible, because there are too many description_lines
    if (current - offset) >= (usable_height_for_items - 1):
        offset = max(current - usable_height_for_items + 2, 0)

    # Collect lines to show. For now, we collect a list of tuples, where
    # each item of a tuple corresponds to a column.
    lines = []
    for issue in issues:
        if issue.fields.assignee:
            assignee = issue.fields.assignee.displayName
        else:
            assignee = ''

        created = datetime.fromisoformat(issue.fields.created[0:19])

        lines.append((
            issue.key,
            issue.fields.status.name,
            issue.fields.summary,
            created.strftime('%d.%m.%Y %H:%M'),
            issue.fields.creator.displayName,
            assignee,
        ))

    # Find max length for each column. Later on, columns may get padded
    # to this length if they're too short.
    header = ('Key', 'Status', 'Summary', 'Created', 'Creator', 'Assignee')
    lens = {}
    for l in [header] + lines:
        for i, element in enumerate(l):
            curmax = lens.get(i, 0)
            lens[i] = max(curmax, len(element))

    # "Summary" is special. All the other columns behave nicely, but
    # Summary can grow very large or stay very short. We will make this
    # the one column that just gets all the remaining space (but a
    # minimum width of 10).
    consumed = 0
    for idx, l in lens.items():
        if idx != 2:
            consumed += l + 2  # + 2 because of padding between columns
    lens[2] = max(width - consumed, 10)

    # Note that, when we show lines, we truncate them to "width" either
    # way. Allows us to handle very small screens.
    addstr(screen, margin_top, 0, fmt_line(header, lens, width))

    y = margin_top + 1
    for i, issue in enumerate(lines[offset:]):
        if y >= margin_top + usable_height_for_items:
            break

        attrs = curses.color_pair(COLORS['default'])

        if i + offset == current:
            attrs |= curses.A_REVERSE

        addstr(screen, y, 0, fmt_line(issue, lens, width), attrs)

        y += 1

    y = margin_top + usable_height_for_items


    # comments and watchers may or may not be present, so we just wrap
    # everything in a try..except to ignore all errors, same as we do
    # with description
    watchers = '???'

    try:
        watchers = issues[current].fields.watches.watchCount
    except AttributeError:
        pass

    created = datetime.fromisoformat(issues[current].fields.created[0:19])
    updated = datetime.fromisoformat(issues[current].fields.updated[0:19])

    addstr(screen, y, 0, line('{key} {summary} | {watchers} watcher{ws} | Created on {created} | Last updated on {updated}'.format(
            key=issues[current].key,
            summary=issues[current].fields.summary,
            watchers=watchers,
            ws='' if watchers == 1 else 's',
            created=created.strftime('%d.%m.%Y %H:%M'),
            updated=updated.strftime('%d.%m.%Y %H:%M'),
        ), width), curses.color_pair(COLORS['bar']))

    y += 1

    for description_line in description_lines:
        addstr(screen, y, 0, description_line)

        y += 1



def open_permalink(link):
    if 'permalink' not in config['external']:
        return

    args = config['external']['permalink'].split(' ')

    signal(SIGCHLD, SIG_IGN)

    args_now = []
    for a in args:
        if a == '__LINK__':
            args_now.append(link)
        else:
            args_now.append(a)

    Popen(args_now, stdout=DEVNULL, stderr=DEVNULL)



def termira(screen):
    global config, query

    curses.curs_set(False)
    curses.use_default_colors()
    curses.init_pair(COLORS['bar'], curses.COLOR_WHITE, curses.COLOR_BLUE)

    refresh_every = timedelta(seconds=30)
    refresh_delta = timedelta(seconds=0)

    issues = None

    current = 0
    offset = 0

    current_mode = 'overview'
    last_mode = ''

    while True:
        height, width = screen.getmaxyx()

        if (issues is None or force_refresh) and query != '':
            status(screen, '██████████  Refreshing ...')
            screen.refresh()

            selected = set()
            issues = jira.search_issues(query, maxResults=False)
            last_key = datetime.now()
            refresh_delta = timedelta(seconds=0)
            force_refresh = False

        screen.erase()

        if current_mode == 'help':
            title(screen, 'termira {} | q: Quit | ?: leave help screen'.format(termira_version))
            status(screen, '')
            show_help_screen(screen)

        elif current_mode == 'overview':
            title(screen, 'termira {} | q: Quit | ?: Help/JQL list | {} Issues returned by search'.format(termira_version, len(issues)))
            status(screen, default_status(screen, query, refresh_delta, refresh_every))
            show_issues(screen, offset, current, issues)

        elif current_mode == 'transition':
            title(screen, 'termira {} | Enter transition ID or press enter to leave'.format(termira_version))
            force_refresh = show_transition(screen, offset, current, issues)
            current_mode = 'overview'

        else:
            status(screen, "ERROR: '"+current_mode+"' is not a valid view mode")

        screen.refresh()
        screen.timeout(1000)


        try:
            char = screen.getkey()
        except:
            char = None
        screen.timeout(-1)

        if char in ['q']:
            return

        if char in ['l']:
            open_permalink(issues[current].permalink())

        if char in ['t']:
            current_mode = 'transition'

        if char in ['r']:
            force_refresh = True
            current_mode = 'overview'

        if char in ['R']:
            config_tmp = configparser.ConfigParser()
            config_tmp.read(path.expanduser('~/.termira.ini'))

            if len(config_tmp['queries'].keys()) > 0:
                config = config_tmp

                q_list = list(config['queries'].keys())
                query = config['queries'][q_list[0]]
                force_refresh = True

            current_mode = 'overview'

        if char in ['f']:
            q = query_string(screen, 'filter alias or JQL: ')

            if q in config['queries']:
                force_refresh = True
                query = config['queries'][q]
            elif q != '':
                force_refresh = True
                query = q

            current_mode = 'overview'

        if char in ['?', 'h']:
            if current_mode == 'help':
                current_mode = last_mode

            else:
                last_mode = current_mode
                current_mode = 'help'


        bottompad = starty = 2

        if char in ['j', 'KEY_DOWN']: current += 1
        if char in ['k', 'KEY_UP']: current -= 1

        if char in ['g', 'KEY_HOME']: current = 0
        if char in ['G', 'KEY_END']: current = len(issues) - 1

        if current < 0:
            current = 0
        if current >= len(issues):
            current = len(issues) - 1

        if current - offset >= (height - bottompad) - starty:
            offset = current - (height - bottompad) + starty + 1
        if current - offset <= -1:
            offset = current

        if offset < 0:
            offset = 0
        if offset >= len(issues):
            offset = len(issues) - 1

        if char is not None:
            last_key = datetime.now()
            refresh_delta = timedelta(seconds=0)
        else:
            refresh_delta = datetime.now() - last_key
            if refresh_delta > refresh_every:
                force_refresh = True
                last_key = datetime.now()


if __name__ == '__main__':
    while True:
        try:
            config.read(path.expanduser('~/.termira.ini'))

            if 'jira' not in config:
                raise KeyError("Required Group 'jira' is missing in config")

            jira = JIRA(config['jira']['url'], auth=(config['jira']['user'], config['jira']['pass']), timeout=10, async_=True, max_retries=2)

            queries = list(config['queries'].keys())
            if len(queries) < 1:
                raise KeyError('No Queries defined in config')

            query = config['queries'][queries[0]]

            curses.wrapper(termira)
            exit(0)
        except JIRAError as e:
            print("JIRA Error: {}".format(e.status_code))
            print(e.text)
            print()
            input('Press enter to reset and continue.')
        except Exception:
            print('It appears we had a whoopsie. Please report this.')
            print()
            print_exc()
            print()
            input('Press enter to reset and continue.')
